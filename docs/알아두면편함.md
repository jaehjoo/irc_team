### IRC 클라이언트와 서버가 실제로 주고 받는 거 확인하기
- inspircd
	- inspircd --runasroot --nofork
- tcpflow 이용하기
	- tcpflow
		- linux와 unix 계열에서 쓰이는 네트워크 트래픽 분석 도구
	- tcpflow -i lo port 6667 -c
		- -i : 네트워크 인터페이스를 결정. ip 주소로 지정 가능하며 여기서는 lo(loopback)
		- port : 확인할 대상의 포트 번호
		- -c : 추적한 데이터를 파일에 쓰지 않고 표준 출력으로 내보내는 것
### 레벨 트리거 vs 엣지 트리거
- 레벨 트리거는 버퍼에 데이터가 남아있거나(read), 버퍼가 가득차지 않은(write) 경우에는 계속 해당 이벤트를 호출한다. poll 함수를 예시로 들면 전자는 POLLIN이 계속 감지되고 후자는 POLLOUT이 계속 감지되는 식. 버퍼에 내용물이 남아있거나 비어있는 지 확인하기 편하지만 지속적으로 이벤트를 시스템 콜 하는 만큼 소켓이 많을 수록 부하가 높아진다
	- 단, 만일 read() 에러가 발생하더라도 버퍼가 비워있지 않으면 레벨 트리거 특성상 계속 이벤트를 감지하니 다시 이벤트 감지된 대로 버퍼를 읽으러 가면 그만이다.
- 엣지 트리거는 이벤트가 감지되면 한 번만 호출한다. 즉, read 이벤트는 이벤트를 호출한 이후에 버퍼가 전부 비워지고 다시 버퍼가 채워져야 이벤트를 감지하고 write 이벤트는 버퍼가 채워지고 다시 비워져야 감지한다. 그렇기에 중간에 버퍼를 일부 읽지 못해서 그대로 버퍼가 남아있는 경우, 이를 감지하지 않기에 무한 대기 상태에 빠질 수 있다. 그래서 read의 경우, 논블럭 소켓을 이용해 버퍼가 비워질 때까지 받고 버퍼가 비워진 경우 -1 에러를 받아 빠져나온다.
	- 단 엣지 트리거의 경우에는 -1이 정말로 버퍼가 비워져서 받은 건지, 아니면 read 에러라서 못 받은 건지 별도로 errno를 검사하지 않으면 알 수 없다. 
	- kqueue의 경우, EVFILT_READ 이벤트를 통해 읽기를 시도할 때, 이벤트 감지용인 kevent 구조체의 data를 보면 이벤트가 감지되었을 때 데이터가 얼마나 버퍼에 쌓였는 지 크기를 알 수 있다. 즉, 소켓 버퍼의 내용물을 사용자가 제작한 버퍼에 다 채운 후에 빠져 나오면 끝나는 셈이다.
		- errno를 쓰지 않아도 실현 가능